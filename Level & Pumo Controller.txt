// LCD module connections
sbit LCD_RS at RB4_bit;
sbit LCD_EN at RB3_bit;
sbit LCD_D4 at RB2_bit;    ///
sbit LCD_D5 at RB1_bit;   //
sbit LCD_D6 at RD7_bit;   //
sbit LCD_D7 at RD6_bit;

sbit LCD_RS_Direction at TRISB4_bit;
sbit LCD_EN_Direction at TRISB3_bit;
sbit LCD_D4_Direction at TRISB2_bit;  //
sbit LCD_D5_Direction at TRISB1_bit;  //
sbit LCD_D6_Direction at TRISD7_bit;  //
sbit LCD_D7_Direction at TRISD6_bit;
// End LCD module connections

unsigned int SET_FREQ=0;

unsigned int FBV=0;
unsigned int PHASE_FREQUENCY=0;
unsigned char FB_Step=0;
unsigned char adder=0;
float counter=0;
unsigned char Frequency_Flag=0;


char txt[15];     // float need [15]

unsigned int LCD_Page=0;


int k3=0;

int angle = 100;

unsigned  int x=0;

float SpeedOfSound=0.0;

float Vout=0.0;
double  Rt = 0.0;
double  Tc, Tf = 0.0;
int adc = 0;
int TX_Temp;

int TEMPERATURE =0;

float T=0.0 ;

const float T0=(float)1/298.15;     //  25Â°C = 298.15 Kelvin .
const float  BB=(float)1/3380 ;    //  B is the beta constant of the NTC =3380 (SEE DATASHEET).


unsigned  int Distance=0;
long k1=0;
long j=0;
char check_sonic = 0;

char Index = 0;

int Master_T_Height         = 21;
int Master_T_Pump_OFF_Level = 15;
int Master_T_Minimum        = 5;
int Master_T_Pump_ON_Level  = 10;
int Master_T_Level          = 0;

int Pump_T_Height    = 21;
int Pump_T_Maximum   = 15;
int Pump_T_ON_Level  = 8;
int Pump_T_OFF_Level = 5;
int Pump_T_Level     = 0;

int Humidity         = 0;


char Servo_Flag=0;

char Openning_Flag=0;



void Buzzer(){

  Sound_Init(&PORTC, 5);

  Sound_Play(2600, 100);
  Sound_Play(2400, 100);
  Sound_Play(2600, 100);
  
  delay_ms(500);

  Sound_Play(2600, 100);
  Sound_Play(2400, 100);
  Sound_Play(2600, 100);


  }



void Servo(){
     while(1)
            {
             if(PORTC.F6==0){if(angle<224){angle++;}} //   165
             if(PORTB.F0==0){if(angle>48){angle--;}}  // 35

             for(x=0;x<=1900;x++){if(x<angle){PORTD.F2=1;}else{PORTD.F2=0;} }   // 1400 had been calibrated using oscilloscope to be 20ms
             if(PORTC.F0==1){Servo_Flag=0;break;}
            }
      }
                 



void print(){

      Buzzer();

      Lcd_Out(1, 2, "LEVEL & PUMP");
      Lcd_Out(2, 3, "CONTROLLER");
      delay_ms(5000);

      lcd_cmd(_LCD_CLEAR);
      Lcd_Out(1, 3, "DESIGNED By");
      Lcd_Out(2, 3, "Leen Bilto");
      delay_ms(5000);



Keep_Tracking :

                Index = 1 ; // 1 = Master_T  ,  2 = Pump_T
                   

                ADCON0 = 0B00001001 ;   // ADC Module ON , Chanel 1 (AN1) choosed ,
                adc  = adc_read(1);     // reading the analog volt on pin RA1 .

                T=T0+(BB*log(((float)1023/adc )-1));     // PROBMEL IS HERE , NO ENOGH RAM TO MAKE mathmatics
                T=1/T;
                T=T-273.15;
                k3=T;

                delay_ms(20);          // time for Ultrasonic circuit stabilization .

                TX_Temp=T ;

                SpeedOfSound=(float)(331.3+(0.606*T)); // speed of sound m/s=(331.3 + (0.606 * Tc))m/s . Tc is the temperature in Celsius .
                SpeedOfSound= SpeedOfSound*100 ;        // speed of sound Cm/s .

                delay_ms(100);
                ADCON0.F0=0;  // ADC Module OFF
                   
                   

 All_Index :

                  Distance=0;
                  k1=0;
                  check_sonic=0;

      twin:

              TMR1H =0B00000000;                           //Sets the Initial Value of Timer1 .
              TMR1L =0B00000000;                           //Sets the Initial Value of Timer1 .

        if(Index==1){
                     PORTC.F2=1;           // TRIGERING
                     delay_us(10);
                     PORTC.F2=0;
                    }
        if(Index==2){
                     PORTD.F0=1;           // TRIGERING
                     delay_us(10);
                     PORTD.F0=0;
                    }


              delay_ms(2);      //  this calibrated practicaly , dont decrease or increase of this delay time(delay_ms(2);) other wise you may get error readings for Distance value .



              if(Index==1){for(j=0;j<=50000;j++){if(PORTC.F3==1){  break;}delay_us(1);}}  // If you increase the delay time more than j<=50000; that me effect on performance of   void External_Powered()
              if(Index==2){for(j=0;j<=50000;j++){if(PORTD.F1==1){  break;}delay_us(1);}}

              T1CON.F0=1;

              if(check_sonic>=1 & j>=50000){k1=0; goto cont;}
              if(j>=50000){check_sonic++;goto twin;}

              check_sonic=0;

              if(Index==1){for(j=0;j<=50000;j++){if(PORTC.F3==0){ break;} delay_us(1);}}
              if(Index==2){for(j=0;j<=50000;j++){if(PORTD.F1==0){ break;} delay_us(1);}}

              T1CON.F0=0;    // stop TIMER1

              k1 = ((TMR1H<<8)|TMR1L  );  //Reads Timer1 Value

              k1=k1*1 ;  //   k1=k1*1 because prescaler is 1:1

              k1= SpeedOfSound*( (float)k1/2000000)/2;        //


  cont:


             Distance=k1;    // converting from (Longe k1 variable To  unsigned int Distance variable ) , Long variable may cary decimal values which cannot be transmitteted as UART .

             if(Index==1){Master_T_Level = Master_T_Height - Distance ;}
             if(Index==2){Pump_T_Level   = Pump_T_Height   - Distance ;}

             Index++;

             if(Index < 3){ goto All_Index ; }


             
update:

     if(LCD_Page==0){
              lcd_cmd(_LCD_CLEAR);

              IntToStr(Master_T_Level , txt);
              LTRIM(txt);
              Lcd_Out(1, 1, "Master ");
              Lcd_Out_Cp(txt);
              Lcd_Out_Cp("cm");


              IntToStr(Pump_T_Level , txt);
              LTRIM(txt);
              Lcd_Out(2, 1, "Pump   ");
              Lcd_Out_Cp(txt);
              Lcd_Out_Cp("cm");

              if(LCD_Page==0){while(PORTB.F0==0){} }
              }

     if(LCD_Page==1){

              lcd_cmd(_LCD_CLEAR);
              IntToStr(TX_Temp , txt);
              LTRIM(txt);
              Lcd_Out(1, 1, "Temp  ");
              Lcd_Out_Cp(txt);
              Lcd_Chr_Cp(223);     // Digree symbole
              Lcd_Chr_Cp('C');


              Humidity = 60;

              IntToStr(Humidity , txt);
              LTRIM(txt);
              Lcd_Out(2, 1, "Humid ");
              Lcd_Out_Cp(txt);
              Lcd_Out_Cp("%");

              if(LCD_Page==1){while(PORTB.F0==0){} }

                    }

              if(Master_T_Level <= Master_T_Pump_ON_Level & Pump_T_Level >= Pump_T_ON_Level  ){PORTD.F4=1;} // Pump ON
              if(Master_T_Level >= Master_T_Pump_OFF_Level || Pump_T_Level <= Pump_T_OFF_Level  ){PORTD.F4=0;}

              delay_ms(1000);


      if(Openning_Flag==0){
      while(PORTC.F6==0 )
            {
              Openning_Flag=1;

             if(PORTC.F6==0){if(angle<224){angle++;}} //   165

             for(x=0;x<=1900;x++){if(x<angle){PORTD.F2=1;}else{PORTD.F2=0;} }   // 1400 had been calibrated using oscilloscope to be 20ms

            } }
            
      if(Openning_Flag==1){
      while(PORTC.F6==0 )
            {
              Openning_Flag=0;


             if(PORTC.F6==0){if(angle>48){angle--;}} //   165

             for(x=0;x<=1900;x++){if(x<angle){PORTD.F2=1;}else{PORTD.F2=0;} }   // 1400 had been calibrated using oscilloscope to be 20ms

            }  }



    goto Keep_Tracking ;
    
    
 Exit:
      delay_ms(1);

      }




      
void interrupt(){


        if(INTCON.INTF==1){
                          delay_ms(10);
                          if(PORTB.F0==0){
                          if(LCD_Page==0){LCD_Page = 1; goto pass ;}
                          if(LCD_Page==1){LCD_Page = 0;}
                    pass:

                          if(PORTC.F0==0){Servo_Flag=1;}
                                          }
                          INTCON.INTF=0;
                          }


                 }


void main() {

         ADCON0=0B01000000; ;
         ADCON1=0B01000100;    // PIC16F877  ..  AN0 , AN1 , AN3 are analog inputs

         INTCON.F7= 1;         // Global Interrupt Enable bit
         INTCON.F6= 1;         //Peripheral Interrupt Enable bit

         INTCON.INTE = 1;      // Enables the RB0/INT external interrupt
         INTCON.INTF=0;
         OPTION_REG.f6=0;

         CCP1CON=0B00000000 ;   // ALL comparaters off
         CCP2CON=0B00000000 ;
         
         T1CON.F0=0;
         
         TRISA=0B11111111;
         TRISB=0B11111111;
         TRISC=0B11111111;
         TRISD=0B11111111;
         TRISE=0B00000111;
         
      // LCD
     TRISB.F5=0;
     PORTB.F5=1;   // LCD ON/OFF Port                                                                                         Q

     TRISD.F5=0;
     PORTD.F5=1;   // LCD LED  ON/OFF Port
     // End of LCD
     
     // Ultrasonic Ports
     TRISC.F2=0;  // Triger 1 (T1)
     TRISC.F3=1;  // Echo 1   (E1)
     TRISD.F0=0;  // Triger 2 (T2)
     TRISD.F1=1;  // Echo 2   (E2)
     
     PORTC.F2=0;  // Triger 1 is LOW
     PORTD.F0=0;  // Triger 2 is LOW
     
     // End of Ultrasonic Ports
     
     // Pump Ports
     TRISD.F4=0;
     PORTD.F4=0;   // Pump is OFF .. N-Chanel Mosfet is used
     // End of Pump Ports
     
     // Buzzer Ports
     TRISC.F5=0;
     PORTC.F5=0;   // Buzzer is OFF
     // End of Buzzer Ports Ports
     
     // NTC Ports
     TRISA.F2=0;   //  ADCON1=0B00000100;   // PIC16F877  ..  AN0 , AN1 , AN3 are analog inputs
     PORTA.F2=1;   // Giving VDD to NTC
     TRISA.F1=1;   // NTC Analog input port .
     // End of NTC Ports
     
     
     // Buttons In Put Ports
     TRISB.F0 = 1;         //  External Interrup  ( Yellow Button )
     TRISC.F6 = 1;         //  General Used Input ( Blue Button  )
     // End of Buttons In Put Ports


     // Servo Ports
     TRISD.F2=0;       // Servo signal out put
     PORTD.F2=0;
     // End of Servo Ports
     
     
     // DHT11 Ports
     TRISC.F4=1;
     // End of DHT11 Ports
     

  // LCD initialization
     Lcd_Init();
     lcd_cmd(_LCD_CURSOR_OFF);  // Cursor off.
     lcd_cmd(_LCD_CLEAR);       // Clear display.
  // End of LCD initialization

     delay_ms(200);


     
     angle = 224;
     while(angle>48)
          {
             if(angle>48){}angle--; //   165

             for(x=0;x<=1900;x++){if(x<angle){PORTD.F2=1;}else{PORTD.F2=0;} }   // 1400 had been calibrated using oscilloscope to be 20ms

          }



      delay_ms(100);
      
      print();
     
     }