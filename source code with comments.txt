// LCD module connections
sbit LCD_RS at RB4_bit; // Register Select pin
sbit LCD_EN at RB3_bit; // Enable pin
sbit LCD_D4 at RB2_bit; // Data pin 4
sbit LCD_D5 at RB1_bit; // Data pin 5
sbit LCD_D6 at RD7_bit; // Data pin 6
sbit LCD_D7 at RD6_bit; // Data pin 7
sbit LCD_RS_Direction at TRISB4_bit; // Direction of RS pin
sbit LCD_EN_Direction at TRISB3_bit; // Direction of EN pin
sbit LCD_D4_Direction at TRISB2_bit; // Direction of D4 pin
sbit LCD_D5_Direction at TRISB1_bit; // Direction of D5 pin
sbit LCD_D6_Direction at TRISD7_bit; // Direction of D6 pin
sbit LCD_D7_Direction at TRISD6_bit; // Direction of D7 pin
// End LCD module connections

char txt[5]; // General used variable while printing on LCD
unsigned int LCD_Page = 0; // Page 0 or 1
int k3 = 0; // General used while making mathematical calculations
int angle = 100; // Using to determine the LCD shutter Servo angle
unsigned int x = 0; // General used variable

// Temperature reading used variable using NTC
float SpeedOfSound = 0.0;
int adc = 0;
int TX_Temp;
int TEMPERATURE = 0;
float T = 0.0;
const float T0 = (float)1 / 298.15; // 25°C = 298.15 Kelvin
const float BB = (float)1 / 3380; // B is the beta constant of the NTC = 3380 (SEE DATASHEET)
// End of Temperature reading used variable using NTC

// Ultrasonic Distance reading variables
unsigned int Distance = 0;
long k1 = 0;
long j = 0;
char check_sonic = 0;
char Index = 0;
// End of Ultrasonic Distance reading variables

// Level and Pump Motor variables
int Master_T_Height = 21;
int Master_T_Pump_OFF_Level = 15;
int Master_T_Minimum = 5;
int Master_T_Pump_ON_Level = 10;
int Master_T_Level = 0;
int Pump_T_Height = 21;
int Pump_T_Maximum = 15;
int Pump_T_ON_Level = 8;
int Pump_T_OFF_Level = 5;
int Pump_T_Level = 0;
// End Level and Pump Motor variables

int Humidity = 0;
char Servo_Flag = 0;
char Openning_Flag = 0; // LCD Shutter ON or OFF indicator flag bit

// Fan Motor related variables
int Increased_temp = 0;
int Board_min_temp = 40;
int Board_max_temp = 80;
float temp_percentage = 0.0;
// End of Fan Motor related variables

int First_ON_Flag = 1;

// DHT11 sensor connection (here data pin is connected to pin RC4)
sbit DHT11_PIN at RC4_bit;
sbit DHT11_PIN_Direction at TRISC4_bit;
int humid = 0;
unsigned short T_byte1, T_byte2, RH_byte1, RH_byte2, CheckSum;
// End DHT11 sensor connection

// Custom delay functions
void My_DelayMs(unsigned int ms) {
    unsigned int i, j;
    for (i = 0; i < ms; i++) {
        for (j = 0; j < 167; j++) {
            asm { NOP }
        }
    }
}

void My_DelayUs(unsigned int us) {
    unsigned int i;
    for (i = 0; i < us; i++) {
        asm { NOP }
        asm { NOP }
    }
}

// Custom sound play function
void My_SoundPlay(unsigned long freq, unsigned int duration_ms) {
    unsigned long i, toggleCount;
    unsigned int halfPeriod_us;
    toggleCount = (freq * duration_ms) / 1000UL;
    halfPeriod_us = (unsigned int)(500000UL / freq);
    for (i = 0; i < toggleCount; i++) {
        PORTC |= (1 << 5);
        My_DelayUs(halfPeriod_us);
        PORTC &= ~(1 << 5);
        My_DelayUs(halfPeriod_us);
    }
}

// Custom ADC initialization function
void My_ADC_Init(void) {
    ADCON1 = 0x84;
    ADCON0 = 0x00;
    ADCON0 = 0b01000001;
}

// Custom ADC read function
unsigned int My_ADC_Read(unsigned short channel) {
    ADCON0 &= 0b11000101;
    channel <<= 3;
    ADCON0 |= channel;
    My_DelayMs(2);
    ADCON0 |= (1 << 2);
    while (ADCON0 & (1 << 2)) {}
    return ((ADRESH << 8) + ADRESL);
}

// Custom PWM initialization function
void My_PWM2_Init(void) {
    PR2 = 124;
    T2CON = 0b00000001;
    CCP2CON = 0b00001100;
    CCPR2L = 0x00;
    T2CON |= (1 << 2);
}

// Custom PWM set duty function
void My_PWM2_SetDuty(unsigned char duty) {
    CCPR2L = duty >> 2;
    CCP2CON = (CCP2CON & 0xCF) | ((duty & 0x03) << 4);
}

// Custom PWM start function
void My_PWM2_Start(void) {
    T2CON |= (1 << 2);
}

// Custom PWM stop function
void My_PWM2_Stop(void) {
    T2CON &= ~(1 << 2);
    PORTC &= ~(1 << 1);
}

// DHT11 start signal function
void Start_Signal(void) {
    DHT11_PIN_Direction = 0; // Configure connection pin as output
    DHT11_PIN = 0; // Connection pin output low
    My_DelayMs(25); // Wait 25 ms
    DHT11_PIN = 1; // Connection pin output high
    My_DelayUs(25); // Wait 25 us
    DHT11_PIN_Direction = 1; // Configure connection pin as input
}

// DHT11 check response function
unsigned short Check_Response() {
    TMR1H = 0; // Reset Timer1
    TMR1L = 0;
    TMR1ON_bit = 1; // Enable Timer1 module
    while (!DHT11_PIN && TMR1L < 100); // Wait until DHT11_PIN becomes high (checking of 80µs low time response)
    if (TMR1L > 99) // If response time > 99µS ==> Response error
        return 0; // Return 0 (Device has a problem with response)
    else {
        TMR1H = 0; // Reset Timer1
        TMR1L = 0;
        while (DHT11_PIN && TMR1L < 100); // Wait until DHT11_PIN becomes low (checking of 80µs high time response)
        if (TMR1L > 99) // If response time > 99µS ==> Response error
            return 0; // Return 0 (Device has a problem with response)
        else
            return 1; // Return 1 (response OK)
    }
}

// DHT11 read data function
unsigned short Read_Data(unsigned short* dht_data) {
    short i;
    *dht_data = 0;
    for (i = 0; i < 8; i++) {
        TMR1H = 0; // Reset Timer1
        TMR1L = 0;
        while (!DHT11_PIN) // Wait until DHT11_PIN becomes high
            if (TMR1L > 100) { // If low time > 100 ==> Time out error (Normally it takes 50µs)
                return 1;
            }
        TMR1H = 0; // Reset Timer1
        TMR1L = 0;
        while (DHT11_PIN) // Wait until DHT11_PIN becomes low
            if (TMR1L > 100) { // If high time > 100 ==> Time out error (Normally it takes 26-28µs for 0 and 70µs for 1)
                return 1; // Return 1 (timeout error)
            }
        if (TMR1L > 50) // If high time > 50 ==> Sensor sent 1
            *dht_data |= (1 << (7 - i)); // Set bit (7 - i)
    }
    return 0; // Return 0 (data read OK)
}

// DHT11 main function
void DHT11() {
    T1CON = 0x10; // Set Timer1 clock source to internal with 1:2 prescaler (Timer1 clock = 1MHz)
    TMR1H = 0; // Reset Timer1
    TMR1L = 0;

    Start_Signal(); // Send start signal to the sensor
    if (Check_Response()) { // Check if there is a response from sensor (If OK start reading humidity and temperature data)
        if (Read_Data(&RH_byte1) || Read_Data(&RH_byte2) || Read_Data(&T_byte1) || Read_Data(&T_byte2) || Read_Data(&Checksum)) {
        } else { // If there is no time out error
            if (CheckSum == ((RH_Byte1 + RH_Byte2 + T_Byte1 + T_Byte2) & 0xFF)) {
            }
        }
    }

    T1CON = 0x00;
    TMR1ON_bit = 0; // Disable Timer1 module
    My_DelayMs(1000); // Wait 1 second
}

// Read and print control function
void Read_Print_Control() {
    My_SoundPlay(2600, 100);
    My_SoundPlay(2400, 100);
    My_SoundPlay(2600, 100);
    My_DelayMs(500);
    My_SoundPlay(2600, 100);
    My_SoundPlay(2400, 100);
    My_SoundPlay(2600, 100);
    Lcd_Out(1, 2, "LEVEL & PUMP");
    My_DelayMs(5000);
    lcd_cmd(_LCD_CLEAR);
    Lcd_Out(1, 3, "DESIGNED By");
    Lcd_Out(2, 3, "Leen Bilto");
    My_DelayMs(5000);

Keep_Tracking:
    // Reading Temperature using NTC and determining sound speed according to temperature
    ADCON0 = 0b00001001; // ADC Module ON, Channel 1 (AN1) chosen
    adc = My_ADC_Read(1); // Reading the analog voltage on pin RA1
    T = T0 + (BB * log(((float)1023 / adc) - 1)); // Temperature calculation
    T = 1 / T;
    T = T - 273.15; // Convert Kelvin to Celsius
    k3 = T;
    My_DelayMs(20); // Time for Ultrasonic circuit stabilization
    TX_Temp = (int)T; // Temperature without floats
    SpeedOfSound = (float)(331.3 + (0.606 * T)); // Speed of sound m/s = (331.3 + (0.606 * Tc)) m/s. Tc is the temperature in Celsius
    SpeedOfSound *= 100; // Speed of sound in cm/s
    My_DelayMs(100);
    ADCON0 &= 0xFE; // ADC Module OFF
    DHT11(); // Reading Humidity

    // Fan motor ON/OFF control
    if (TX_Temp > 40) {
        Increased_temp = TX_Temp - Board_min_temp;
        temp_percentage = (float)Increased_temp / 40; // Board_max_temp - Board_min_temp = 40
        My_PWM2_SetDuty((unsigned char)(temp_percentage * 255)); // Maximum pulse width (duty cycle) = 255 = maximum fan motor speed
        My_PWM2_Start();
    }
    if (TX_Temp < 40) {
        My_PWM2_Stop();
        PORTC &= 0xFE;
    }
    // End of Fan motor ON/OFF control

    Index = 1; // 1 = Master_T, 2 = Pump_T

    // Reading Distance for both tanks using Ultrasonic module
All_Index:
    Distance = 0;
    k1 = 0;
    check_sonic = 0;

twin:
    TMR1H = 0x00; // Sets the Initial Value of Timer1
    TMR1L = 0x00; // Sets the Initial Value of Timer1
    if (Index == 1) {
        PORTC |= (1 << 2); // Triggering
        My_DelayUs(10);
        PORTC &= ~(1 << 2);
    }
    if (Index == 2) {
        PORTD |= (1 << 0); // Triggering
        My_DelayUs(10);
        PORTD &= ~(1 << 0);
    }

    My_DelayMs(2);

    if (Index == 1) {
        for (j = 0; j <= 50000; j++) {
            if (PORTC & (1 << 3)) {
                break;
            }
            My_DelayUs(1);
        }
    }
    if (Index == 2) {
        for (j = 0; j <= 50000; j++) {
            if (PORTD & (1 << 1)) {
                break;
            }
            My_DelayUs(1);
        }
    }
    T1CON |= (1 << 0);
    if (check_sonic >= 1 && j >= 50000) {
        k1 = 0;
        goto cont;
    }
    if (j >= 50000) {
        check_sonic++;
        goto twin;
    }
    check_sonic = 0;
    if (Index == 1) {
        for (j = 0; j <= 50000; j++) {
            if (!(PORTC & (1 << 3))) {
                break;
            }
            My_DelayUs(1);
        }
    }
    if (Index == 2) {
        for (j = 0; j <= 50000; j++) {
            if (!(PORTD & (1 << 1))) {
                break;
            }
            My_DelayUs(1);
        }
    }
    T1CON &= ~(1 << 0); // Stop TIMER1
    k1 = ((TMR1H << 8) | TMR1L); // Reads Timer1 Value
    k1 = k1 * 1; // k1 = k1 * 1 because prescaler is 1:1
    k1 = SpeedOfSound * ((float)k1 / 2000000) / 2;

cont:
    Distance = k1; // Converting from (Long k1 variable to unsigned int Distance variable)

    // Calculating liquid levels for both tanks
    if (Index == 1) {
        Master_T_Level = Master_T_Height - Distance;
    }
    if (Index == 2) {
        Pump_T_Level = Pump_T_Height - Distance;
    }
    // End of Calculating liquid levels for both tanks

    Index++;
    if (Index < 3) {
        goto All_Index;
    }
    My_DelayMs(100);

update:
    // Printing all readings on LCD for both pages
    if (LCD_Page == 0) { // Page 0
        lcd_cmd(_LCD_CLEAR);
        IntToStr(Master_T_Level, txt);
        Ltrim(txt);
        Lcd_Out(1, 1, "Master ");
        Lcd_Out_Cp(txt);
        Lcd_Out_Cp("cm");

        IntToStr(Pump_T_Level, txt);
        Ltrim(txt);
        Lcd_Out(2, 1, "Pump ");
        Lcd_Out_Cp(txt);
        Lcd_Out_Cp("cm");
        if (LCD_Page == 0) {
            while (PORTB & (1 << 0)) {}
        }
    }
    if (LCD_Page == 1) { // Page 1
        lcd_cmd(_LCD_CLEAR);
        IntToStr(TX_Temp, txt);
        Ltrim(txt);
        Lcd_Out(1, 1, "Temp ");
        Lcd_Out_Cp(txt);
        Lcd_Chr_Cp(223); // Degree symbol
        Lcd_Chr_Cp('C');

        IntToStr(RH_Byte1, txt);
        Ltrim(txt);
        Lcd_Out(2, 1, "Humid ");
        Lcd_Out_Cp(txt);
        Lcd_Out_Cp("%");
        if (LCD_Page == 1) {
            while (PORTB & (1 << 0)) {}
        }
    }
    // End of printing all readings on LCD for both pages

    // Controlling Pump motor ON/OFF according to determined level settings
    if (Master_T_Level <= Master_T_Pump_ON_Level && Pump_T_Level >= Pump_T_ON_Level) {
        PORTD |= (1 << 4); // Pump ON
    }
    if (Master_T_Level >= Master_T_Pump_OFF_Level || Pump_T_Level <= Pump_T_OFF_Level) {
        PORTD &= ~(1 << 4); // Pump OFF
    }
    // End of Controlling Pump motor ON/OFF according to determined level settings

    My_DelayMs(1000);

    // ON/OFF LCD Shutter
    if (First_ON_Flag == 1) {
        First_ON_Flag = 0;
        Openning_Flag = 1;
        while (angle < 183) {
            if (angle < 183) {
                angle++;
            }
            for (x = 0; x <= 1900; x++) {
                if (x < angle) {
                    PORTD |= (1 << 2);
                } else {
                    PORTD &= ~(1 << 2);
                }
            }
        }
    }

    if (Openning_Flag == 0) {
        while (!(PORTC & (1 << 6))) {
            Openning_Flag = 1;
            if (!(PORTC & (1 << 6)) && angle < 183) {
                angle++;
            }
            for (x = 0; x <= 1900; x++) {
                                PORTD = (x < angle) ? (PORTD | (1 << 2)) : (PORTD & ~(1 << 2));
            }
        }
    }

    if (Openning_Flag == 1) {
        while (!(PORTC & (1 << 6))) {
            Openning_Flag = 0;
            if (!(PORTC & (1 << 6)) && angle > 43) {
                angle--;
            }
            for (x = 0; x <= 1900; x++) {
                PORTD = (x < angle) ? (PORTD | (1 << 2)) : (PORTD & ~(1 << 2));
            }
        }
    }
    // End of ON/OFF LCD Shutter

    goto Keep_Tracking;
}

// Interrupt service routine
void interrupt() {
    if (INTCON & (1 << 1)) { // Interrupt action for scrolling through the 2 LCD pages (page 0 or 1)
        //My_DelayMs(10);
        if (!(PORTB & (1 << 0))) {
            if (LCD_Page == 0) {
                LCD_Page = 1;
            } else {
                LCD_Page = 0;
            }
            if (!(PORTC & (1 << 0))) {
                Servo_Flag = 1;
            }
        }
        INTCON &= ~(1 << 1); // Clear external Interrupt Flag bit
    }
}

// Main function
void main() {
    // ADCON0 and ADCON1 configuration for ADC module
    ADCON0 = 0b01000000;
    ADCON1 = 0b01000100; // PIC16F877: AN0, AN1, AN3 are analog inputs

    // Enable global and peripheral interrupts
    INTCON.F7 = 1; // Global Interrupt Enable bit
    INTCON.F6 = 1; // Peripheral Interrupt Enable bit

    // Timer1 configuration
    T1CON = 0b00000000; // Initializing Timer Module at prescaler value of 1:1

    // Enable external interrupt on RB0/INT pin
    INTCON.INTE = 1; // Enables the RB0/INT external interrupt
    INTCON.INTF = 0; // Clear external Interrupt Flag bit
    OPTION_REG.f6 = 0; // Falling edge

    // Disable comparators
    CCP1CON = 0b00000000; // Stop comparators
    CCP2CON = 0b00000000; // Stop comparators

    // Configure TRIS registers for input/output
    TRISA = 0b11111111;
    TRISB = 0b11111111;
    TRISC = 0b11111111;
    TRISD = 0b11111111;
    TRISE = 0b00000111;

    // LCD initialization
    TRISB.F5 = 0;
    PORTB.F5 = 1; // LCD ON/OFF Port
    TRISD.F5 = 0;
    PORTD.F5 = 1; // LCD LED ON/OFF Port

    // Ultrasonic Ports configuration
    TRISC.F2 = 0; // Trigger 1 (T1)
    TRISC.F3 = 1; // Echo 1 (E1)
    TRISD.F0 = 0; // Trigger 2 (T2)
    TRISD.F1 = 1; // Echo 2 (E2)
    PORTC.F2 = 0; // Trigger 1 is LOW
    PORTD.F0 = 0; // Trigger 2 is LOW

    // Pump Ports configuration
    TRISD.F4 = 0;
    PORTD.F4 = 0; // Pump is OFF, N-Channel Mosfet is used

    // Buzzer Ports configuration
    TRISC.F5 = 0;
    PORTC.F5 = 0; // Buzzer is OFF

    // NTC Ports configuration
    TRISA.F2 = 0; // ADCON1=0b00000100; // PIC16F877: AN0, AN1, AN3 are analog inputs
    PORTA.F2 = 1; // Giving VDD to NTC
    TRISA.F1 = 1; // NTC Analog input port

    // Buttons Input Ports configuration
    TRISB.F0 = 1; // External Interrupt (Yellow Button)
    TRISC.F6 = 1; // General Used Input (Blue Button)

    // Servo Ports configuration
    TRISD.F2 = 0; // Servo signal output
    PORTD.F2 = 0;

    // DHT11 Ports configuration
    TRISC.F4 = 1;

    // H-Bridge Ports configuration
    TRISC.F1 = 0; // Clockwise rotation, PWM output
    TRISC.F7 = 0; // Anti-clockwise rotation
    PORTC.F1 = 0;
    PORTC.F7 = 0;

    // LCD initialization
    Lcd_Init();
    lcd_cmd(_LCD_CURSOR_OFF); // Cursor off
    lcd_cmd(_LCD_CLEAR); // Clear display

    My_DelayMs(200);
    My_PWM2_Init(); // Initialize PWM module at a frequency of 1000Hz

    // Calibrate the shutter at the right angle
    angle = 224;
    while (angle > 43) {
        angle--;
        for (x = 0; x <= 1900; x++) {
            if (x < angle) {
                PORTD |= 0x04;
            } else {
                PORTD &= 0xFB;
            }
        }
    }
    My_DelayMs(100);

    // Start the main application
    Read_Print_Control();
}